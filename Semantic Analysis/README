README file for Programming Assignment 4 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile
 README
 ast-lex.cc		-> [cool root]/src/PA4/ast-lex.cc
 ast-parse.cc		-> [cool root]/src/PA4/ast-parse.cc
 bad.cl
 cgen			-> [cool root]/etc/../lib/.i
 cool-tree.cc		-> [cool root]/src/PA4/cool-tree.cc
 cool-tree.h
 cool-tree.handcode.h
 dumptype.cc		-> [cool root]/src/PA4/dumptype.cc
 good.cl
 handle_flags.cc	-> [cool root]/src/PA4/handle_flags.cc
 mycoolc		-> [cool root]/src/PA4/mycoolc
 mysemant		-> [cool root]/src/PA4/mysemant
 semant-phase.cc	-> [cool root]/src/PA4/semant-phase.cc
 semant.cc
 semant.h
 stringtab.cc		-> [cool root]/src/PA4/stringtab.cc
 symtab_example.cc	-> [cool root]/src/PA4/symtab_example.cc
 tree.cc		-> [cool root]/src/PA4/tree.cc
 utilities.cc		-> [cool root]/src/PA4/utilities.cc
 *.d			  dependency files

The include (.h) files for this assignment can be found in 
[cool root]/include/PA4

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code.  Just edit this file.

	good.cl and bad.cl test a few features of the semantic checker.
	You should add tests to ensure that good.cl exercises as many
	legal semantic combinations as possible and that bad.cl
	exercises as many kinds of semantic errors as possible.

	semant.h contains declarations and definitions for the semantic
	analyzer.  Place class definitions for the structures you will
	use here.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.  DO
        NOT MODIFY.

        cool-tree.h, and cool-tree.handcode.h specify and give an
        implementation of Cool ASTs (see the README for PA3 and the
        "Cool Tour").  In this assignment, you will need to add
        functions to the AST classes to store, fetch, and compute
        information about the AST.  Note that cool-tree.handcode.h
        differs slightly from the file supplied for PA3.

   	You should NOT remove any definitions that are already present
	in cool-tree.h and cool-tree.handcode.h.  These functions and
	data members are required for the system to function properly.

        You should add any fields and methods to the classes you need to 
	perform semantic analysis.  You	will need to add, for example, 
	methods which traverse the expressions of the tree and implement 
	the type-checking rules.

	cool-tree.cc contains definitions of the provided methods,
	and instantiations of the template for the list handling functions.
	You should not modify this file, but place definitions of all
	methods you add to cool-tree.h or cool-tree.handcode.h in semant.cc.
	DO NOT MODIFY cool-tree.cc

	semant.cc is the file in which you should write your semantic
	analyzer.  The main() procedure calls the method `semant'
	on `ast_root', the root of the abstract syntax tree generated by
	the parser.  There are methods supplied that you should use to report 
	errors. You are relatively free in how you decide to structure the 
	semantic checker, but don't modify the error printing routines.

	ast-lex.cc and ast-parse.cc implement a lexer and a parser for
	reading text representation of ASTs from console in the format
	produced by the parser phase. DO NOT MODIFY.

	semant-phase.cc contains a test driver for semantic analysis.
	The main program reads an AST in text form from standard input,
	parses it, and then produces a type-annotated AST on standard
	output.  The script mycoolc can pass any of the standard flags
	to the semantic analyzer as well; for this assignment, -s
	(semantic analysis debug) may be useful as it sets a global
	variable semant_debug to true (1).  If you want your semantic
	checker to print debug information when the option is set, write
	your debug code in the following format:

	      if (semant_debug)
	      {
		...
	      }

	semant_debug is provided as a convenience. You don't need to use
	the debugging flags if you don't want to. DON'T MODIFY
	semant-phase.cc

	symtab.h contains a symbol table implementation. Read the
	comments in the file, the "Cool Tour", and look at the example
	in symtab_example.cc.  You are not required to use this code,
	but you may find it useful. DO NOT MODIFY.

Instructions
------------

	To compile the example use of the symbol table, type

	% make symtab_example
        % ./symtab_example

	To compile your semantic analyzer program type:

	% make semant

	To test your semantic checker, type:

        % ./mysemant good.cl

	mysemant is a version of mycoolc that omits code generation.
	mysemant parses all the cool files given on the command line and
	builds a single abstract syntax tree containing all class
	definitions appearing in the input files. Your semantic checker
	is then called on this abstract syntax tree.  If there are no
	errors, the program produces a type-annotated abstract syntax
	tree as output.

	To run your checker on the files good.cl and bad.cl type:

	% make dotest

	If you think your semantic checker is correct and behaves like
	the one we wrote, you can try to run mycoolc using your checker,
	your parser and also your lexical analyzer if you choose (see
	below for instructions).  Remember if your lexer, parser or
	checker behaves in an unexpected manner, you may get errors
	anywhere.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA4
----------------

In this lab Semantic Checker is bulit upon some major topics. They are<
	1. builds an Inheritance graph
	2. Check Whether the graph is well-formed
	3. Traversing the AST
	4. Type correctness
	5. Types annotations

In the Building an inheritance grapgh step we created a class symbol table.
Then check whether the class name is not match the names of the fundamental classes.
After that check whther the class had a previously been implemented. If this class had been implemented
previously the then error is displayed. If the it isnot implemented previously then the appropriate classes are added
to the class symbol table.

Initialy the main function is searched to check whetherif the Main class was in the program.Also check and verified 
that the main method is implemented inside the Main class.

Then traversing the AST we need to verify its semantically correctness. for that 
verify all the parent classes have been specified, Determine whether Object class have a parent class
and check for inherited bool self types and strings. These steps are followed verify its semantically correctness.
Also the functions of the class should be checked. Because there are some cases susch as,
method has not been specified ,whether the return type has been implemented in the program and t will be added to the current scope if the method passes 
all of the preceding criteria. Further the attributes of the class has to be checked for whether check  Whether or not all kinds have been defined,
.Also to check whether  whether the "attribute" has previously been specified,if the name of the "attribute" is not the same as "self"
and The "attribute" will be added to the current "scope" if it passes all of the aforementioned criteria.

When consdiering the type correctness the expressions and formals in features were examined and also assigned types to
expressions. When this done characteristics of the classes is examined. Because to check whether assigned phrase is semantically accurate
and assigning a type to it.if the attribute's type declaration is the same as the expression type. The following things are examined
when checking the method of the classes.
	1. creating a new "scope" 
	2. ensuring that all formals (arguments) are semantically valid
	3. Is it true that formal names are not the same as'self'?
	4. Is the formal name not already defined in the current version?
	5. formals are added to the current scope if they are semantically valid.
	6. If the return type is 'SELF TYPE,' change the return type to 
		that of the current class type.
	7. Assign a type to the method body(expression) 
		if it is semantically valid 
	8. Is the method's return type the same as the method's body type?

Class definition in the COOL programming si kind of diffrent from the class definition.In here
type and features of each class might be utilized before the class definition.Therfroe two passes are necessary.
In here all the program classes are added to a database. This is called as the class symbol table during the first pass.
Also the feature table of each class has benn updated with each ones methods and attributes.Therfore it is feasible to keep the track
of all classes and features declaration in the program. In the second pass the expressions are tested for semantic correctness.
These are the two passes that have to e done.

In this we used semant_expr() function to type check for all the expressions type in coll language.This function check for types 
including the arithmatic operations and boolean operations. The followings are the all the expression types resolved with the function;
	

	1.assignType
	2.blockType
	3.bool_constType
	4.caseType
	5.compType
	6.condType
	7.disatchType
	8.divType
	9.eqType
	10.int_constType
	11.isvoidType
	12.letType
	13.loopType
	14.ltType
	15.mulType
	16.negType
	17.no_exprType
	18.newType
	19.objectType
	20.plusType
	21.static_dispatchType
	22.string_constType
	23.subType
