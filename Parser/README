README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [cool root]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [cool root]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [cool root]/src/PA3/dumptype.cc
 handle_flags.c           -> [cool root]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [cool root]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [cool root]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [cool root]/src/PA3/tokens-lex.cc
 tree.cc		  -> [cool root]/src/PA3/tree.cc
 utilities.cc		  -> [cool root]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[cool root]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% make parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

The design decisions
--------------------

The main thing in cool.y is precedence and Associtivity. Each operator has precedence. That is done according to below fromat.
	%nonassoc IN
	%right ASSIGN 
	%left '@' .. etc
After that the each syantax ruke were written. Note that these rules are related to each syntax. 
	program , class_list,class, feature_list, features, formal_list, formal, expression,expr_parameters,expr_statments are 
	thedifferent rule types. This all definition can be found in th cool.y file.

Lists
-----
	COOL grammer allows formals, features and classes etc lists.Since thises lists do not have a fixed size these should be recursive.
	Left recursion was used because Bison prefers leftrecursion.



The ultimate goal of the parser is to obtain the AST. AST should have a root node. 

AST generation
--------------
	The AST generation was done using the functions available in 
	cool-tree.cc. There was a function defined for each kind of 
	construct. For any rule matched, its value is assigned using '$$'.


For the all the root node is program and it is the mainnode of the AST. In the program there are two scenarios. 
Fist one is program have a one class and second one is program has multiple classes.
Program smust have atleast one class (Main class). Therefore the classes are the next level of the AST (after the root node)

When considering the class , class have the identification(signature) and the definitions (What is this class do?). Therefore we need to add
class definition as the next level of the AST. Therfore class definition is considered as feature_list. Menas the next level of the AST (After the classes)
is feature_list.When condiering the class deifintion also there are two posibilities. They are
	
	1. Definition is empty
	2. Definition is not empty

Not empty defintions are considered as feature list. And since class can have empty defintion this feature list is null. This null condition is also handled.

Upto now in the AST we have program as the root node. And classes as the next level and after the classes feature list is added. Each feature list have features. The number of the features can be zero or many. Therfore the features are considered as the next level of the AST. When considering the features they are two categories. Attributes and the methods. To make that methdo or the attribute relevant constructor function is used. These function can be foung in the cool-tree.h and cool-tree.cc as mentioned in the before.

In the method definition of feature definition parameters of the method is taken as the formal_list, making that as the next 
level of AST. Also expression was used while defining feature.When there are optional extensions to the rule definition, in the constructor , no_expr() function is used to pass that parameter 

Then the next level is formal. Then the eexpr_statments,expr_parameters,expr_let and expr_case are the next. 

The following errors were caught in the design.
	Consider the class_list	- If there is an error in a class definition, the parser skips the current class, and continues parsing from the next class.
	
	feature_list
	
		If there is an error in a feature definition, the parser skips 
		the	current feature, and continues parsing from the next feature
		of the class.
	
	expr_list
		If there is an error in any of the expressions in an expression 
		block, the parser skips those expressions but parsers the others.
	
	let_list
		If there is an error in the declaration part of a let construct,
		the parser skips the whole let the statement (including the "IN"
		part). However, if there is an error in the "IN" part, it is
		handled in one of the above cases.



